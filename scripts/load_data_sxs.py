"""
Process gravitational waveform data from SXS simulations.

This script loads gravitational waveform data (strain) and black hole horizon
data from HDF5 files generated by SXS (Simulating eXtreme Spacetimes)
simulations. It converts the strain data into ASCII format, with separate files
for each spherical harmonic mode ell. It also extracts and saves black hole
positional and spin data into an ASCII file.

It also generates apparent horizon surface files (.gp) for gnuplot visualization.

Author: Zachariah B. Etienne
        zachetie **at** gmail **dot* com
"""
import numpy as np
import os
import sys
import sxs

def convert_strain_to_ascii(strain: sxs.WaveformModes, output_dir: str) -> None:
    """
    Convert strain data from an SXS simulation object into ASCII files.

    One file is created per spherical harmonic mode ell. The files are stored
    in a 'strain' subdirectory within the specified output directory.

    Output Format:
    - Column 1: t (time), as a floating-point number
      formatted to .15e precision.
    - Subsequent columns (one for each Y_lm mode): Y_lm.
      Complex numbers are formatted as a string 'real_part<sign>imag_partj'
      (e.g., '1.234e+00-4.567e-01j'), without parentheses, with .15e precision
      for both real and imaginary parts.
    File names are formatted as Rh_l{ell}-rinfo.txt. (infinite extraction radius)

    :param strain: SXS strain object (e.g., from sim.h). This object should
                   have attributes like .t (time array), .ell_min, .ell_max,
                   and support indexing like .index(ell, m) and strain[:, idx].
    :param output_dir: The directory where the 'strain' subdirectory will be
                       created and output files will be saved.
    :raises FileNotFoundError: If the output directory cannot be created.
    :raises AttributeError: If the strain object is missing required attributes.
    """

    print( # Horizontal line of asterisks
            f"""{'*' * 70}
Converting strain to ASCII documents..."""
         )

    # Create the strain directory if it doesn't exist
    strain_dir = os.path.join(output_dir, 'strain')
    os.makedirs(strain_dir, exist_ok=True)

    ell_min = strain.ell_min
    ell_max = strain.ell_max

    # Calculate retarded time data for the first column
    # Assuming strain.t is a 1D NumPy array of time values.
    retarded_time_data = strain.t

    # Calculate total number of (ell, m) modes for progress tracking
    iterations = ell_max**2 + 2 * ell_max - ell_min**2 + 1
    count = 0

    # Iterate over each ell value
    for ell in range(ell_min, ell_max + 1):
        # Format the output file name
        output_file_name = f"Rh_l{ell}-rinf.txt"
        output_path = os.path.join(strain_dir, output_file_name)

        # List to hold column data. First column is raw floats, subsequent are string arrays.
        data_columns_list = [retarded_time_data]

        # List of format specifiers for np.savetxt, one for each column.
        format_list = ['%.15e'] # Format for the first (time) column

        # Initialize header lines for the current file
        header_lines = [f"# column 0: t [retarded_time]"]
        current_column_index = 1  # Start column numbering for Y_lm data from 2

        # Iterate over each em mode for the current ell
        for em in range(-ell, ell + 1):
            idx = strain.index(ell, em)
            # Access the spherical harmonic mode data Y_lm(t)
            # Assumed to be a 1D NumPy array of complex numbers.
            ylm_mode_data_at_times = strain[:, idx] # This gets the data for the specific mode across all times
            ylm_array = np.array(ylm_mode_data_at_times)

            # Vectorized formatting for complex numbers into a 1D array of strings
            # Example: "1.234567890123456e+00-9.876543210987654e-01j"
            # The :+ in {val.imag:+.15e} ensures the sign (+ or -) is always present for the imaginary part.

            # 1. Separate real and imaginary parts
            real_parts = ylm_array.real
            imag_parts = ylm_array.imag

            # 2. Format each part to string. Then convert to numpy array
            real_strs = np.array([f"{x:.15e}" for x in real_parts])
            imag_strs = np.array([f"{x:+.15e}j" for x in imag_parts]) # 'j' is appended here

            # 3. Concatenate the string arrays element-wise
            complex_str_array_for_mode = np.char.add(real_strs, imag_strs).astype(object)

            data_columns_list.append(complex_str_array_for_mode)
            format_list.append('%s') # Use '%s' for columns that are already strings

            # Add header for the current Y_lm mode column
            header_lines.append(f"# column {current_column_index}: rh_{{l={ell},m={em}}}/M")
            current_column_index += 1

            count += 1
            progress = (count / iterations) * 100
            print(f"\rProgress: {progress:.1f}% completed. Iterated through (ell, em) = ({ell}, {em})", end="", flush=True)

        # Stack all collected 1D data columns horizontally.
        # The resulting array will have dtype=object because it mixes float arrays and object arrays (of strings).
        output_data_array = np.column_stack(data_columns_list)

        # Join header lines into a single string, with each line separated by a newline
        header_string = "\n".join(header_lines)

        # Save the 2D array to a text file using the specified list of formats.
        # np.savetxt will use '%.15e' for the first column and '%s' for the others.
        # Default delimiter is a space.
        np.savetxt(output_path, output_data_array, header=header_string, comments="", fmt=format_list)

    print(f"\nStrain conversion complete. Saved {ell_max - ell_min + 1} files to {strain_dir}")

def _generate_sphere_coords(center, radius, N_theta=30, N_phi=60):
    """
    Generates a gnuplot-compatible string of coordinates for a sphere.

    :param center: (cx, cy, cz) tuple/list for the sphere's center.
    :param radius: Radius of the sphere.
    :param N_theta: Resolution for theta (polar angle).
    :param N_phi: Resolution for phi (azimuthal angle).
    :return: A string formatted for gnuplot 'splot'.
    """
    theta_vals = np.linspace(0, np.pi, N_theta)
    phi_vals = np.linspace(0, 2 * np.pi, N_phi)
    cx, cy, cz = center

    # Store formatted coordinate strings
    gnuplot_blocks = []

    # Create a grid: iterate over phi, then theta
    # Each block of constant phi is separated by a blank line
    for phi in phi_vals:
        coord_lines_for_block = []
        for theta in theta_vals:
            x = cx + radius * np.sin(theta) * np.cos(phi)
            y = cy + radius * np.sin(theta) * np.sin(phi)
            z = cz + radius * np.cos(theta)

            # Format to match the example .gp file (%.10e)
            # FIX: Changed :%.10e to :.10e
            coord_lines_for_block.append(f"{x:.10e} {y:.10e} {z:.10e}")

        # Join all lines for this block
        gnuplot_blocks.append("\n".join(coord_lines_for_block))

    # Join all blocks, separated by two newlines (one blank line)
    return "\n\n".join(gnuplot_blocks)

def generate_apparent_horizons(output_dir: str, time: np.ndarray, merger_index: int,
                               xA: np.ndarray, yA: np.ndarray, zA: np.ndarray, amA: np.ndarray,
                               xB: np.ndarray, yB: np.ndarray, zB: np.ndarray, amB: np.ndarray) -> None:
    """
    Generates gnuplot-compatible .gp files for the apparent horizons.

    Iterates through each timestep, treating areal mass as the radius and
    the (x, y, z) coordinates as the center of a sphere. Generates spherical
    coordinate samples and saves them to files.

    Before merger (i < merger_index):
    - h.t#######.ah1.gp (from BH A data)
    - h.t#######.ah2.gp (from BH B data)

    After merger (i >= merger_index):
    - h.t#######.ah3.gp (from BH C data, which is in the A arrays)

    :param output_dir: The base directory (e.g., 'data/simulation_name').
    :param time: Array of time values.
    :param merger_index: The array index at which the common horizon (C)
                         data begins.
    :param xA, yA, zA, amA: Arrays for BH1 (A) and then common (C) horizon.
    :param xB, yB, zB, amB: Arrays for BH2 (B) and then common (C) horizon.
    """

    print( # Horizontal line of asterisks
            f"""\n{'*' * 70}
Generating apparent horizon .gp files..."""
         )

    # Create the 'horizons' directory in the output path
    horizon_dir = os.path.join(output_dir, 'horizons')
    os.makedirs(horizon_dir, exist_ok=True)

    total_times = len(time)
    if total_times == 0:
        print("No time steps found to generate horizon files.")
        return

    files_generated = 0

    # Generate a file for each time step
    for i in range(total_times):
        t = time[i]

        # Format time string: rounded down, 7 digits, zero-padded
        # e.g., t=123.45 -> "0000123"
        time_str = f"{int(np.floor(t)):07d}"

        # Standard header for all .gp files
        header_template = (
            "# gnuplot-compatible horizon surface data, at time {t:.3f}.\n"
            "# Column 1: x coordinate\n"
            "# Column 2: y coordinate\n"
            "# Column 3: z coordinate"
        )

        if i < merger_index:
            # Before merger: generate files for ah1 and ah2

            # --- Black Hole 1 (ah1) ---
            r1 = amA[i]
            c1 = (xA[i], yA[i], zA[i])
            file_path1 = os.path.join(horizon_dir, f"h.t{time_str}.ah1.gp")
            header1 = header_template.format(t=t)
            data_string1 = _generate_sphere_coords(c1, r1)

            try:
                with open(file_path1, 'w') as f:
                    f.write(header1 + "\n")
                    f.write(data_string1 + "\n")
                files_generated += 1
            except IOError as e:
                print(f"\nWarning: Could not write to file {file_path1}. Error: {e}")

            # --- Black Hole 2 (ah2) ---
            r2 = amB[i]
            c2 = (xB[i], yB[i], zB[i])
            file_path2 = os.path.join(horizon_dir, f"h.t{time_str}.ah2.gp")
            header2 = header_template.format(t=t)
            data_string2 = _generate_sphere_coords(c2, r2)

            try:
                with open(file_path2, 'w') as f:
                    f.write(header2 + "\n")
                    f.write(data_string2 + "\n")
                files_generated += 1
            except IOError as e:
                print(f"\nWarning: Could not write to file {file_path2}. Error: {e}")

        else:
            # After merger: generate one file for ah3 (using ah1/C data)

            # --- Common Horizon (ah3) ---
            r3 = amA[i] # Data from C is concatenated onto A arrays
            c3 = (xA[i], yA[i], zA[i]) # Data from C is concatenated onto A arrays
            file_path3 = os.path.join(horizon_dir, f"h.t{time_str}.ah3.gp")
            header3 = header_template.format(t=t)
            data_string3 = _generate_sphere_coords(c3, r3)

            try:
                with open(file_path3, 'w') as f:
                    f.write(header3 + "\n")
                    f.write(data_string3 + "\n")
                files_generated += 1
            except IOError as e:
                print(f"\nWarning: Could not write to file {file_path3}. Error: {e}")

        progress = ((i + 1) / total_times) * 100
        print(f"\rProgress: {progress:.1f}% completed. Generated files for t = {t:.3f}", end="", flush=True)

    print(f"\nApparent horizon file generation complete. Saved {files_generated} files to {horizon_dir}")

def extract_black_hole_positions(horizons, output_dir: str) -> None:
    """
    Extract black hole horizon data and save it to a text file.

    The data includes center-of-mass positions, areal mass, Christodoulou mass,
    and spin for two black holes (A and B) and the common horizon (C).
    The output file is named 'puncture_posns_vels_regridxyzU.txt'.

    This function also triggers the generation of .gp files for the
    apparent horizons.

    :param horizons: SXS horizons object (e.g., from sim.horizons). This object
                     should have attributes A, B, and C, each with sub-attributes
                     like .time, .areal_mass, .christodoulou_mass,
                     .coord_center_inertial, .dimensionful_inertial_spin,
                     .dimensionful_inertial_spin_mag, .chi_inertial, .chi_mag_inertial.
    :param output_dir: The directory where the output file will be saved.
    :raises AttributeError: If the horizons object or its sub-objects are
                            missing required attributes.
    :raises FileNotFoundError: If the output directory does not exist or the
                               file cannot be written.
    """

    print( # Horizontal line of asterisks
            f"""\n{'*' * 70}
Extracting black hole horizon data..."""
         )

    # Data for BH1 comes from horizons.A and then horizons.C (common horizon)
    # Data for BH2 comes from horizons.B and then horizons.C (common horizon)

    time = np.concatenate((horizons.A.time, horizons.C.time))
    merger_index = len(horizons.A.time)

    # BH1 data from A, then C
    amA = np.concatenate((horizons.A.areal_mass, horizons.C.areal_mass))
    cmA = np.concatenate((horizons.A.christodoulou_mass, horizons.C.christodoulou_mass))
    xA = np.concatenate((horizons.A.coord_center_inertial[:, 0], horizons.C.coord_center_inertial[:, 0]))
    yA = np.concatenate((horizons.A.coord_center_inertial[:, 1], horizons.C.coord_center_inertial[:, 1]))
    zA = np.concatenate((horizons.A.coord_center_inertial[:, 2], horizons.C.coord_center_inertial[:, 2]))
    disxA = np.concatenate((horizons.A.dimensionful_inertial_spin[:, 0], horizons.C.dimensionful_inertial_spin[:, 0]))
    disyA = np.concatenate((horizons.A.dimensionful_inertial_spin[:, 1], horizons.C.dimensionful_inertial_spin[:, 1]))
    diszA = np.concatenate((horizons.A.dimensionful_inertial_spin[:, 2], horizons.C.dimensionful_inertial_spin[:, 2]))
    dismA = np.concatenate((horizons.A.dimensionful_inertial_spin_mag, horizons.C.dimensionful_inertial_spin_mag))
    xixA = np.concatenate((horizons.A.chi_inertial[:, 0], horizons.C.chi_inertial[:, 0]))
    xiyA = np.concatenate((horizons.A.chi_inertial[:, 1], horizons.C.chi_inertial[:, 1]))
    xizA = np.concatenate((horizons.A.chi_inertial[:, 2], horizons.C.chi_inertial[:, 2]))
    ximA = np.concatenate((horizons.A.chi_mag_inertial, horizons.C.chi_mag_inertial))

    # BH2 data from B, then C
    amB = np.concatenate((horizons.B.areal_mass, horizons.C.areal_mass))
    cmB = np.concatenate((horizons.B.christodoulou_mass, horizons.C.christodoulou_mass))
    xB = np.concatenate((horizons.B.coord_center_inertial[:, 0], horizons.C.coord_center_inertial[:, 0]))
    yB = np.concatenate((horizons.B.coord_center_inertial[:, 1], horizons.C.coord_center_inertial[:, 1]))
    zB = np.concatenate((horizons.B.coord_center_inertial[:, 2], horizons.C.coord_center_inertial[:, 2]))
    disxB = np.concatenate((horizons.B.dimensionful_inertial_spin[:, 0], horizons.C.dimensionful_inertial_spin[:, 0]))
    disyB = np.concatenate((horizons.B.dimensionful_inertial_spin[:, 1], horizons.C.dimensionful_inertial_spin[:, 1]))
    diszB = np.concatenate((horizons.B.dimensionful_inertial_spin[:, 2], horizons.C.dimensionful_inertial_spin[:, 2]))
    dismB = np.concatenate((horizons.B.dimensionful_inertial_spin_mag, horizons.C.dimensionful_inertial_spin_mag))
    xixB = np.concatenate((horizons.B.chi_inertial[:, 0], horizons.C.chi_inertial[:, 0]))
    xiyB = np.concatenate((horizons.B.chi_inertial[:, 1], horizons.C.chi_inertial[:, 1]))
    xizB = np.concatenate((horizons.B.chi_inertial[:, 2], horizons.C.chi_inertial[:, 2]))
    ximB = np.concatenate((horizons.B.chi_mag_inertial, horizons.C.chi_mag_inertial))

    # The primary time column used for output will be time.
    # All other arrays (amA, cmA, ..., ximA, amB, ..., ximB) should have compatible lengths

    # --- Generate apparent horizon .gp files ---
    generate_apparent_horizons(
        output_dir, time, merger_index,
        xA, yA, zA, amA,  # BH1/C data
        xB, yB, zB, amB   # BH2 data
    )
    # --- End new call ---

    generate_bh_file(output_dir, time, amA, cmA, xA, yA, zA, disxA, disyA, diszA, dismA, xixA, xiyA, xizA, ximA,
                     amB, cmB, xB, yB, zB, disxB, disyB, diszB, dismB, xixB, xiyB, xizB, ximB)

def generate_positions_from_metadata(time, metadata, output_dir: str) -> None:
    n_times = len(time)

    xA, yA = [], []

    orbital_freq = metadata.initial_orbital_frequency
    init_separation = metadata.initial_separation
    massA = metadata.initial_mass1
    massB = metadata.initial_mass2
    dimspinA = metadata.initial_dimensionless_spin1
    dimspinB = metadata.initial_dimensionless_spin2
    positionA = metadata.initial_position1
    positionB = metadata.initial_position2
    merger_time = metadata.merger_time

    try:
        phi0 = np.arctan(positionA[1] / positionA[0]) # Get initial angle from arctan(y0/x0)
    except ZeroDivisionError:
        phi0 = np.pi / 2 * np.sign(positionA[1]) # Use +/- pi/2 for when x0 = 0

    for idx, t in enumerate(time):
        magnitude = init_separation / 2 * (1 - t / merger_time)
        xA.append(magnitude * np.cos(2 * np.pi * orbital_freq + phi0))
        yA.append(magnitude * np.sin(2 * np.pi * orbital_freq + phi0))

    xB, yB = [-x for x in xA], [-y for y in yA]
    print(xB)
    print(yB)

    zA, zB = np.full(n_times, 0), np.full(n_times, 0)
    amA = np.full(n_times, massA)
    amB = np.full(n_times, massB)
    cmA = np.full(n_times, massA)
    cmB = np.full(n_times, massB)
    disxA = np.full(n_times, dimspinA[0])
    disyA = np.full(n_times, dimspinA[1])
    diszA = np.full(n_times, dimspinA[2])
    dismA = np.full(n_times, np.sqrt(dimspinA[0]**2 + dimspinA[1]**2 + dimspinA[2]**2))
    xixA = np.full(n_times, 0)
    xiyA = np.full(n_times, 0)
    xizA = np.full(n_times, 0)
    ximA = np.full(n_times, 0)
    disxB = np.full(n_times, dimspinB[0])
    disyB = np.full(n_times, dimspinB[1])
    diszB = np.full(n_times, dimspinB[2])
    dismB = np.full(n_times, np.sqrt(dimspinB[0]**2 + dimspinB[1]**2 + dimspinB[2]**2))
    xixB = np.full(n_times, 0)
    xiyB = np.full(n_times, 0)
    xizB = np.full(n_times, 0)
    ximB = np.full(n_times, 0)

    # --- Generate apparent horizon .gp files ---
    # For metadata-generated positions, there is no "merger".
    # Set merger_index to n_times so it only generates ah1 and ah2 files.
    merger_index = n_times
    generate_apparent_horizons(
        output_dir, time, merger_index,
        np.array(xA), np.array(yA), zA, amA,  # BH1 data
        np.array(xB), np.array(yB), zB, amB   # BH2 data
    )
    # --- End new call ---

    generate_bh_file(output_dir, time, amA, cmA, xA, yA, zA, disxA, disyA, diszA, dismA, xixA, xiyA, xizA, ximA,
                     amB, cmB, xB, yB, zB, disxB, disyB, diszB, dismB, xixB, xiyB, xizB, ximB)

def generate_bh_file(output_dir, time, amA, cmA, xA, yA, zA, disxA, disyA, diszA, dismA, xixA, xiyA, xizA, ximA,
                     amB, cmB, xB, yB, zB, disxB, disyB, diszB, dismB, xixB, xiyB, xizB, ximB) -> None:

    # Create the puncture directory if it doesn't exist
    puncture_dir = os.path.join(output_dir, 'puncture')
    os.makedirs(puncture_dir, exist_ok=True)

    data = np.vstack((time, amA, cmA, xA, yA, zA, disxA, disyA, diszA, dismA, xixA, xiyA, xizA, ximA,
                      amB, cmB, xB, yB, zB, disxB, disyB, diszB, dismB, xixB, xiyB, xizB, ximB)).T

    # Generate header
    header = [
        "# column 0: t = [time]",
        "# column 1 (bh_1), 14 (bh_2): am = [areal_mass]",
        "# column 2 (bh_1), 15 (bh_2): cm = [christodoulou_mass]",
        "# column 3 (bh_1), 16 (bh_2): x = [positions_x]",
        "# column 4 (bh_1), 17 (bh_2): y = [positions_y]",
        "# column 5 (bh_1), 18 (bh_2): z = [positions_z]",
        "# column 6 (bh_1), 19 (bh_2): disx = [dimensionful_inertial_spin_x]",
        "# column 7 (bh_1), 20 (bh_2): disy = [dimensionful_inertial_spin_y]",
        "# column 8 (bh_1), 21 (bh_2): disz = [dimensionful_inertial_spin_z]",
        "# column 9 (bh_1), 22 (bh_2): dism = [dimensionful_inertial_spin_mag]",
        "# column 10 (bh_1), 23 (bh_2): xix = [chi_inertial_x]",
        "# column 11 (bh_1), 24 (bh_2): xiy = [chi_inertial_y]",
        "# column 12 (bh_1), 25 (bh_2): xiz = [chi_inertial_z]",
        "# column 13 (bh_1), 26 (bh_2): xim = [chi_mag_inertial]"]

    # Save the output
    output_file = os.path.join(puncture_dir, "puncture_posns_vels_regridxyzU.txt")
    np.savetxt(output_file, data, header="\n".join(header), comments="", fmt="%.15e")
    print(f"Saved black hole positions to {output_file}")

if __name__ == "__main__":
    args = len(sys.argv)
    if args not in range(2, 6): # Expects 1 to 4 arguments + script name
        raise ValueError(f"""Usage: python3 {os.path.basename(__file__)}
                             <simulation_name (e.g. SXS:BBH:3890)>
                             [extrapolation (e.g. L1 for linear]>
                             [version (e.g. 3.0)]
                             [resolution (e.g. Lev3)]""")

    # Extract SXS simulation name and virtual extraction radius
    simulation_name = sys.argv[1]

    # Extract version, resolution, and extrapolation, if included.
    extrapolation = "N4"
    version = None
    resolution = None

    if args >= 3:
        extrapolation = sys.argv[2]
        e = ValueError("Extrapolation must be in the format Nx, where x is a positive integer")
        if not extrapolation[0] == "N": # Ensure extrapolation starts with "N"
            raise e
        try:
            if int(extrapolation[1:]) <= 0: # What follows must be a positive integer
                raise e
        except ValueError:
            raise e

        if args >= 4:
            version = sys.argv[3]
            e = ValueError("Version must be a decimal number greater than 0")
            try:
                if float(version) <= 0: # Version must be an decimal greater than zero
                    raise e
            except ValueError:
                raise e

            if args == 5:
                resolution = sys.argv[4]
                e = ValueError("Extrapolation must be in the format Levx, where x is a positive integer")

                if not resolution[:3] == "Lev": # Ensure resolution starts with "Lev"
                    raise e
                try:
                    if int(resolution[3:]) <= 0: # What follows must be a positive integer
                        raise e
                except ValueError:
                    raise e
    try:
        # Path for simulation data, formatted to include version and resolution if provided. Otherwise, the database
        # will load the latest version and highest resolution.
        sim_path = simulation_name + f"{'' if version==None else 'v' + version}" + f"{'' if resolution==None else '/' + resolution}"
        sim = sxs.load(sim_path, extrapolation="N4") # Loads strain data extrapolated to null infinity.
                                                     # Extrapolated with quartics
    except RuntimeError as e:
        raise RuntimeError(f"""An error ocurred during SXS data loading: {e}
                           SXS simulations are named in the format SXS:<BBH or BHNS or NSNS>:####""")


    simulation_path = os.path.join("..", "data", simulation_name)

    # Create the output directory if it doesn't exist
    os.makedirs(simulation_path, exist_ok=True)

    # Convert the HDF5 file to ASCII
    convert_strain_to_ascii(sim.h, simulation_path)

    horizons = None
    try:
        horizons = sim.horizons
    except ValueError:
        print("WARNING: No position data found for bodies. Estimating positions from metadata.")

    if not horizons == None:
        # Extract black hole positions and save to ASCII
        extract_black_hole_positions(sim.horizons, simulation_path)
    else:
        try:
            generate_positions_from_metadata(sim.h.t, sim.metadata, simulation_path)
        except ValueError as e:
            raise ValueError("No metadata found: {e}")

    print("\nConversion and extraction complete.")
